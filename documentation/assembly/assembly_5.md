 # 메모리 크기 지정
 - 402000번지에 EAX를 넣어라
    - mov [402000], EAX -> mov dword ptr ds: [402000], EAX
    - dword ptr?
    - ds?

    - mov [402000], AX -> mov word ptr ds: [402000], AX
    - word ptr?
    - ds?

    - mov [402000], AL -> mov byte ptr ds: [402000], AL
    - byte ptr?
    - ds?

    - ptr : 메모리의 공간을 가리키는 포인터
        - dword ptr : double word, 4바이트
        - word ptr : 2바이트
        - byte ptr : 1바이트

        > 컴퓨터 구조에서 word는 32비트 컴퓨터에서는 32비트를 말하는데 인텔 어셈블리어에서는 AX에서 살펴봤듯이 16비트에서 확장된 개념이기 때문에 16비트에서 사용했던 저장 크기를 지칭하는 이름을 같이 했다.

    - mov dword ptr: [402000], EAX 
        - 402000부터 4바이트 공간을 이용하겠다.
    - mov word ptr: [402000], AX
        - 402000부터 2바이트 공간을 이용하겠다.
    - mov byte ptr: [402000], AL
        - 402000부터 1바이트 공간을 이용하겠다.
    > mov A, B : A와 B의 `크기가 같아야 한다`.

    - 실행결과
        - EAX 75459191
        - ECX 12345678
        - EDX 87654321

        - mov dword ptr: [402000], EAX 
        - 402000번지 : 91 91 45 75 (little endian 이라 자리수가 반대로 결과값이 들어간다.)

        - mov dword ptr: [402000], CX 
        - 402000번지 : 78 56 45 75 (little endian 이라 자리가 반대로 결과값이 들어간다.)

        - mov dword ptr: [402000], DL
        - 402000번지 : 21 56 45 75 (little endian 이라 자리가 반대로 결과값이 들어간다.)

    - 첫 번째 주소와 크기를 이용하면 저장공간에 여러 바이트를 쉽게 접근할 수 있다.
    - NOP : NoOperation -> 이 명령어를 읽으면 cpu에서 pass한다.

    - mov [402000], 0
        - 0의 크기를 알 수 없다 -> 크기를 지정해야 한다.
        - mov dword ptr ds: [402000], 0

    - DS
        - 데이터 세그먼트 : 데이터를 읽어오겠다.;
        - 16비트 일 때 
            - 메모리가 20 바이트를 지정할 수 있다.
            - 레지스터 16 + 세그먼트 = 20
        
        - 그 외에도
            - CS : 코드 영역을 가리키는 데이터
            - DS : 데이터 영역을 가리키는 데이터
            - ES : 여분
            - FS
            - GS
            - SS : 스택 영역을 가리키는 데이터 

            - 해당 영역을 가리키는 데이터를 담고 있다.
    