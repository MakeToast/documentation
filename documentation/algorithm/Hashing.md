- Hash Table
    - 해쉬 테이블은 dynamic set을 구현하는 효과적인 방법의 하나
        - 적절한 가정하에서 평균 탐색, 삽입, 삭제시간 O(1)
        - 보통 최악의 경우 O(n) 
    - 해쉬 함수(hash function) h를 사용하여 키 k를 T[h(k)]에 저장
        - h : U -> {0, 1, ..., m-1}, 여기서 m은 테이블의 크기, U는 모든 가능한 키들의 집합
        - 키 k가 h(k)로 해싱되었다고 말한다.
    ![HASH TABLE](https://t1.daumcdn.net/cfile/tistory/2744703859117EC226)
    - 해쉬 함수의 예
        - 모든 키들을 자연술고 가정. 어떤 데이터든지 자연수로 해석하는 것이 가능
        - 예 : 문자열
            - ASCII 코드 : C = 67, L = 76, R = 82, s = 83
            - 문자열 CLRS는 (67*128^3) + (76*128^2) + (82*128^1) + (83*128^0) = 141,764,947
        
        - 해쉬 함수의 간단한 예 :
            - h(k) = k % m, 즉 key를 하나의 자연수로 해석한 후 테이블의 크기 m으로 나눈 나머지
            - 항상 0~m-1 사이의 정수가 됨
    - 충돌(Collision)
        - 두 개 이상의 키가 동일한 위치로 해싱되는 경우
        - 즉, 서로 다른 두 키 k1과 k2에 대해서 h(k1) = h(k2)인 상황
        - 일반적으로 |U| >> m이므로 항상 발생 가능 (즉 단사 함수가 아님)
        - 만약 |K| > m라면 당연히 발생, 여기서 K는 실제로 저장된 키들의 집합
        - 충돌이 발생할 경우 대처 방법이 필요
        - 대표적인 두 가지 충돌 해결 방법 : `chaining`과 `open addressing`
        - `Chaining`에 의한 충돌 해결
            - 동일한 장소로 해싱된 모든 키들을 하나의 연결리스트(Linked List)로 저장
            - ***키의 삽입(Insertion)***
                - 키 k를 리스트 T[h(k)]의 맨 앞에 삽입 : 시간복잡도 O(1)
                - 중복된 키가 들어올 수 있고 ***중복 저장이 허용되지 않는다면*** 삽입시 리스트를 검색해야 한다. 따라서 시간복잡도는 `리스트의 길이에 비례`
            - ***키의 검색(Search)***
                - 리스트 T[h(k)]에서 `순차 검색`
                - 시간 복잡도는 키가 저장된 `리스트의 길이에 비례.`
            - ***키의 삭제(Deletion)***
                - 리스트 T[h(k)]로부터 키를 검색 후 삭제
                - 일단 키를 검색헤서 찾은 후에 O(1)시간에 삭제 가능
            - 최악의 경우는 모든 키가 하나의 슬롯으로 해싱되는 경우
                - 길이가 n인 하나의 연결리스트가 만들어짐
                - 따라서 최악의 경우 탐색시간은 O(n)+해쉬함수 계산시간
            - 평균시간복잡도는 키들이 여러 슬롯에 얼마나 잘 분배되느냐에 의해서 결정

        - `Open Addressing`에 의한 충돌 해결
            - 모든 키를 해쉬 테이블 자체에 저장
            - 테이블의 각 칸(slot)에는 1개의 키만 저장
            - 충돌 해결 기법
                - Linear probing
                    - 어떤 값을 h(k)에 저장해야 할 때 h(k)에 키가 저장되어 있으면 h(k)+1, h(k)+2, ... 순서로 검사하여 처음으로 빈 슬롯에 저장한다.
                    - 테이블의 끝에 도달하면 다시 처음으로 circular하게 돌아간다.
                    ![linear probing](https://t1.daumcdn.net/cfile/tistory/273E843C5911978224)
                    - 단점 
                        - primary cluster : 키에 의해서 채워진 연속된 슬롯들을 의미
                        - 이런 cluster가 생성되면 이 cluster는 점점 더 커지는 경향이 생김 -> 검색시간 증가
                - Quadratic probing
                    - 충돌 발생시 h(k), h(k)+1^2, h(k)+2^2, h(k)+3^2, ... 순서로 시도
                - Double hashing
                    - 서로 다른 두 해쉬 함수 h1과 h2를 이용하여 h(k, i) = (h1(k) + i*h2(k)) mod m 
            - 단순히 키를 삭제할 경우 문제가 발생
                - 가령 A, B, C,가 순서대로 모두 동일한 해쉬함수 값을 가져서 linear probing으로 충돌 해결
                - B를 삭제한 후 C 검색                           
- SUHA(Simple Uniform Hashing Assumption)
    - 각각의 키가 모든 슬롯(칸)들에 균등한 확률로 (equally likely) 독립적으로 (independently) 해싱된다는 가정 
        - `성능분석을 위해서 주로 하는 가정`임
        - hash함수는 deterministic하므로(nonrandom) 현실에서는 불가능
    - Load factor a(=알파) = n/m :
        - n : 테이블에 저장될 키의 개수
        - m : 해쉬테이블의 크기, 즉 연결리스트의 개수
        - 각 슬롯에 저장된 키의 평균 개수
    - 연결리스트 T[j]의 길이를 nj라고 하면 E[nj] = a(=알파)
    - 만약 n = O(m)이면 평균검색시간은 `O(1)`

- 좋은 해쉬 함수란?
    - 현실에서는 키들이 랜덤하지 않음
    - 만약 키들의 통계적 분포에 대해 알고 있다면 이를 이용해서 해쉬 함수를 고안하는 것이 가능하겠지만 현실적으로 어려움
    - 키들이 어떤 특정한 (가시적인) 패턴을 가지더라도 해쉬함수 값이 불규칙적이 되도록 하는 것이 바람직
        - 해쉬함수 값이 키의 특정 부분에 의해서만 결정되지 않아야 함

- 해쉬 함수 구현
    - Division 기법
        - h(k) = k mod m
        - 예 : m = 20 and k = 91 -> h(k) = 11.
        - 장점 : 한번의 mod 연산으로 계산. 따라서 빠름.
        - 단점 : 어떤 m값에 대해서는 해쉬 함수값이 키값의 특정 부분에 의해서 결정되는 경우가 있음. 가령 m=2^p이면 키의 하위 p비트가 해쉬 함수값이 됨.
    - Multiplication 기법
        - 0에서 1 사이의 상수 A를 선택: 0 < A < 1
        - kA의 소수부분만을 택한다.
        - 소수 부분에 m을 곱한 후 소수점 아래를 버린다.
        - 예 : m=8, word size = w = 5, k = 21
            - A = 13/32를 선택
            - kA = 21*13/32 = 273/32 = 8+17/32
            - m (kA mod 1) = 8 * 17/32 = 17/4 = 4.xxxx
            - h(21) = 4
    