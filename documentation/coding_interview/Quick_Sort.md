# Quick Sort
- performance : O(n log n), wort case O(n^2)
- space complexity : O(n)
> 리스트가 정렬된 상태에서 퀵소트를 하면 최악의 시간복잡도를 가진다.<br>
> 퀵소트는 따로 메모리를 사용하지 않는다. 현재 있는 메모리 안에서 정렬하기 때문에 아주 좋은 space complexity를 가지고 있다.<br>

- example 
    * step 1. pivot을 정한다. pivot보다 작은 데이터는 왼쪽, 큰 데이터는 오른쪽에 정렬
    * step 2. 왼쪽 데이터들과 오른쪽 데이터들에게 step 1을 반복한다.

    * | 8 | 13 | 2 | 6 | 1 | 4 |
        * pivot : 4 (리스트의 마지막 데이터를 pivot으로 사용)
        * wall `||` 을 두고 pivot보다 작으면 왼쪽 크면 오른쪽에 두자. 
        * pivot < 8 
        * || | 8 | 13 | 2 | 6 | 1 | 4 |
        * pivot < 13    
        * || | 8 | 13 | 2 | 6 | 1 | 4 |
        * pivot > 2 -> 벽의 왼쪽에 있어야 한다 -> 8과 `스와핑` -> wall을 한 칸 이동시킨다.
        * | 2 | || | 13 | 8 | 6 | 1 | 4 |
        * pivot < 6  
        * | 2 | || | 13 | 8 | 6 | 1 | 4 |
        * pivot > 1 ->  벽의 왼쪽에 있어야 한다 -> 3과 `스와핑` -> wall을 한 칸 이동시킨다.
        * | 2 | 1 | || | 8 | 6 | 13 | 4 |
        * 한 번 다 순회했으므로 벽의 위치와 pivot `스와핑`
        * | 2 | 1 | || | 4 | 6 | 13 | 8 |

    * | 2 | 1 | || | 4 | 6 | 13 | 8 |
        * 왼쪽 리스트 quick sort
        * | 2 | 1 |
        * pivot : 1
        * wall `||` 을 두고 pivot보다 작으면 왼쪽 크면 오른쪽에 두자. 
        * pivot < 2
        * || | 2 | 1 |
        * 한 번 다 순회했으므로 벽의 위치와 pivot `스와핑`
        * | 1 | 2 |

        * 1, 4는 피봇이였고 2는 하나만 남았으므로 정렬이 완료되었다.

    * | 1 | 2 | 4 | || | 6 | 13 | 8 |
        * 오른쪽 리스트 quick sort 
        * | 6 | 13 | 8 |
        * pivot : 8
        * wall `||` 을 두고 pivot보다 작으면 왼쪽 크면 오른쪽에 두자. 
        * pivot > 6 -> wall을 한 칸 이동시킨다.
        * | 6 | || | 13 | 8 |
        * pivot < 13
        * | 6 | 13 | || | 8 |
        * 한 번 다 순회했으므로 벽의 위치와 pivot `스와핑`
        * | 6 | 8 | 13 |

        * 8은 피봇이였고 6, 13은 하나만 남았으므로 정렬이 완료되었다.